import React, { useState, useEffect, useRef, useCallback } from 'react';
import { X, BarChart3, LineChart, TrendingUp, Settings, Maximize2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { KdbQueryResult, ChartConfig } from '@/types/kdb';

interface ChartModalProps {
  isOpen: boolean;
  onClose: () => void;
  data: KdbQueryResult;
}

type ChartType = 'line' | 'bar' | 'scatter' | 'histogram' | 'area';

export function ChartModal({ isOpen, onClose, data }: ChartModalProps) {
  const [chartConfig, setChartConfig] = useState<ChartConfig>({
    type: 'bar',
    xColumn: '',
    yColumn: '',
    yColumns: [],
    title: 'Data Visualization'
  });
  const [showSettings, setShowSettings] = useState(true);
  const [chartDimensions, setChartDimensions] = useState({ width: 1200, height: 700 });
  const [isResizing, setIsResizing] = useState(false);
  const [filteredTickValues, setFilteredTickValues] = useState<string[] | null>(null);
  const chartRef = useRef<HTMLDivElement>(null);
  const resizeStartRef = useRef<{ x: number; y: number; width: number; height: number } | null>(null);

  const numericColumns = data.columns.filter((_, index) => {
    const sampleValues = data.data.slice(0, 10).map(row => row[index]);
    return sampleValues.some(val => typeof val === 'number' && !isNaN(val));
  });

  const categoricalColumns = data.columns.filter(column => !numericColumns.includes(column));

  // Set default columns when modal opens
  useEffect(() => {
    if (isOpen && numericColumns.length >= 2) {
      setChartConfig(prev => ({
        ...prev,
        xColumn: numericColumns[0],
        yColumn: numericColumns[1]
      }));
    } else if (isOpen && numericColumns.length === 1 && categoricalColumns.length >= 1) {
      setChartConfig(prev => ({
        ...prev,
        xColumn: categoricalColumns[0],
        yColumn: numericColumns[0]
      }));
    }
  }, [isOpen, data]);

  // Simple, reliable label density calculation
  useEffect(() => {
    if (!isOpen || !data || !data.data || data.data.length === 0) {
      setFilteredTickValues(null);
      return;
    }

    // Calculate target number of ticks based on chart width
    // For rotated labels, we need more space between them
    const labelSpaceNeeded = 100; // pixels per rotated label
    const targetTicks = Math.min(10, Math.max(5, Math.floor(chartDimensions.width / labelSpaceNeeded)));
    
    // Store the target tick count (we'll use this in Plot.js config)
    setFilteredTickValues([targetTicks.toString()]);
  }, [isOpen, data, chartConfig.xColumn, chartConfig.yColumn, chartDimensions.width]);

  // Handle ESC key to close modal
  useEffect(() => {
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = '';
    };
  }, [isOpen, onClose]);

  // Generate Plotly.js chart
  useEffect(() => {
    if (!chartRef.current || !chartConfig.xColumn || !chartConfig.yColumn || !isOpen) return;

    try {
      // Clear previous chart
      chartRef.current.innerHTML = '';

      // Prepare data for plotting
      const xColumnIndex = data.columns.indexOf(chartConfig.xColumn);
      const yColumnIndex = data.columns.indexOf(chartConfig.yColumn);
      
      if (xColumnIndex === -1 || yColumnIndex === -1) return;

      const plotData = data.data.map(row => ({
        x: row[xColumnIndex],
        y: row[yColumnIndex],
        xLabel: chartConfig.xColumn,
        yLabel: chartConfig.yColumn
      })).filter(d => d.x != null && d.y != null);

      if (plotData.length === 0) return;

      // Use resizable chart dimensions
      const chartWidth = chartDimensions.width;
      const chartHeight = chartDimensions.height;
      
      // Helper function to detect if data is time-based
      const isTimeData = (value: any) => {
        if (typeof value === 'string') {
          // Check for common time formats
          return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value) || 
                 /^\d{2}:\d{2}:\d{2}/.test(value);
        }
        return value instanceof Date;
      };

      // Helper function to format time labels adaptively
      const formatTimeLabel = (value: any, dataPointCount: number, chartWidth: number) => {
        if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value)) {
          const date = new Date(value);
          const hours = date.getHours().toString().padStart(2, '0');
          const minutes = date.getMinutes().toString().padStart(2, '0');
          const seconds = date.getSeconds().toString().padStart(2, '0');
          const milliseconds = date.getMilliseconds().toString().padStart(3, '0');
          
          // Adaptive formatting based on data density and chart width
          if (dataPointCount < 50 || chartWidth > 1400) {
            // Low density or large chart: show full precision
            return `${hours}:${minutes}:${seconds}.${milliseconds}`;
          } else if (dataPointCount < 200 || chartWidth > 1000) {
            // Medium density or medium chart: show seconds
            return `${hours}:${minutes}:${seconds}`;
          } else {
            // High density or small chart: show only hours and minutes
            return `${hours}:${minutes}`;
          }
        }
        return String(value);
      };

      // Determine if x-axis data is time-based
      const xIsTime = plotData.length > 0 && isTimeData(plotData[0].x);
      const dataLength = plotData.length;
      
      // Get target tick count from our simple calculation
      const targetTicks = filteredTickValues && filteredTickValues.length > 0 
        ? parseInt(filteredTickValues[0]) 
        : 8; // fallback
      
      let plot;
      const commonOptions = {
        width: chartWidth,
        height: chartHeight,
        marginLeft: 100,
        marginBottom: xIsTime ? 180 : 150, // Extra space for time labels
        marginTop: 80,
        marginRight: 80,
        title: chartConfig.title,
        style: {
          background: 'hsl(var(--background))',
          color: 'hsl(var(--foreground))',
          fontSize: '14px'
        }
      };

      switch (chartConfig.type) {
        case 'line':
          plot = Plot.plot({
            ...commonOptions,
            marks: [
              Plot.line(plotData, {
                x: 'x',
                y: 'y',
                stroke: '#3b82f6',
                strokeWidth: 2
              }),
              Plot.dot(plotData, {
                x: 'x',
                y: 'y',
                fill: '#3b82f6',
                r: 3
              })
            ],
            x: { 
              label: chartConfig.xColumn,
              tickRotate: xIsTime ? -45 : (plotData.length > 15 ? -45 : 0),
              tickFormat: xIsTime ? (d) => formatTimeLabel(d, dataLength, chartWidth) : (d) => String(d).length > 12 ? String(d).substring(0, 12) + '...' : String(d),
              ticks: targetTicks,
              tickSpacing: Math.floor(chartWidth / targetTicks),
              tickFilter: (values: any[]) => {
                if (values.length <= targetTicks) return values;
                const interval = Math.ceil(values.length / targetTicks);
                return values.filter((_, i) => i % interval === 0);
              }
            },
            y: { label: chartConfig.yColumn }
          });
          break;

        case 'bar':
          // For bar charts, we'll group by x and sum y
          const groupedData = plotData.reduce((acc, curr) => {
            const key = String(curr.x);
            if (!acc[key]) {
              acc[key] = { x: curr.x, y: 0, count: 0 };
            }
            acc[key].y += Number(curr.y) || 0;
            acc[key].count += 1;
            return acc;
          }, {} as Record<string, { x: any; y: number; count: number }>);
          
          const barData = Object.values(groupedData);
          
          plot = Plot.plot({
            ...commonOptions,
            marks: [
              Plot.barY(barData, {
                x: 'x',
                y: 'y',
                fill: '#3b82f6',
                tip: true
              })
            ],
            x: { 
              label: chartConfig.xColumn,
              tickRotate: xIsTime ? -45 : (barData.length > 15 ? -45 : 0),
              tickFormat: xIsTime ? (d) => formatTimeLabel(d, barData.length, chartWidth) : (d) => String(d).length > 12 ? String(d).substring(0, 12) + '...' : String(d),
              ticks: targetTicks,
              tickSpacing: Math.floor(chartWidth / targetTicks),
              tickFilter: (values: any[]) => {
                if (values.length <= targetTicks) return values;
                const interval = Math.ceil(values.length / targetTicks);
                return values.filter((_, i) => i % interval === 0);
              }
            },
            y: { label: `Sum of ${chartConfig.yColumn}` }
          });
          break;

        case 'scatter':
          plot = Plot.plot({
            ...commonOptions,
            marks: [
              Plot.dot(plotData, {
                x: 'x',
                y: 'y',
                fill: '#3b82f6',
                fillOpacity: 0.6,
                r: 4,
                tip: true
              })
            ],
            x: { 
              label: chartConfig.xColumn,
              tickRotate: xIsTime ? -45 : (plotData.length > 20 ? -45 : 0),
              tickFormat: xIsTime ? (d) => formatTimeLabel(d, dataLength, chartWidth) : (d) => String(d).length > 12 ? String(d).substring(0, 12) + '...' : String(d),
              ticks: targetTicks,
              tickSpacing: Math.floor(chartWidth / targetTicks),
              tickFilter: (values: any[]) => {
                if (values.length <= targetTicks) return values;
                const interval = Math.ceil(values.length / targetTicks);
                return values.filter((_, i) => i % interval === 0);
              }
            },
            y: { label: chartConfig.yColumn }
          });
          break;

        case 'histogram':
          if (typeof plotData[0]?.x === 'number') {
            plot = Plot.plot({
              ...commonOptions,
              marks: [
                Plot.rectY(plotData, { ...Plot.binX({ y: 'count' }, { x: 'x' }), fill: '#3b82f6' })
              ],
              x: { 
                label: chartConfig.xColumn,
                tickRotate: xIsTime ? -45 : -45,
                tickFormat: xIsTime ? (d) => formatTimeLabel(d, dataLength, chartWidth) : (d) => String(d).length > 12 ? String(d).substring(0, 12) + '...' : String(d),
                ticks: targetTicks,
              tickSpacing: Math.floor(chartWidth / targetTicks),
              tickFilter: (values: any[]) => {
                if (values.length <= targetTicks) return values;
                const interval = Math.ceil(values.length / targetTicks);
                return values.filter((_, i) => i % interval === 0);
              }
              },
              y: { label: 'Frequency' }
            });
          } else {
            // Fallback to bar chart for non-numeric data
            plot = Plot.plot({
              ...commonOptions,
              marks: [
                Plot.barY(plotData, Plot.groupX({ y: 'count' }, {
                  x: 'x',
                  fill: '#3b82f6',
                  tip: true
                }))
              ],
              x: { 
                label: chartConfig.xColumn,
                tickRotate: xIsTime ? -45 : -45,
                tickFormat: xIsTime ? (d) => formatTimeLabel(d, dataLength, chartWidth) : (d) => String(d).length > 12 ? String(d).substring(0, 12) + '...' : String(d),
                ticks: targetTicks,
              tickSpacing: Math.floor(chartWidth / targetTicks),
              tickFilter: (values: any[]) => {
                if (values.length <= targetTicks) return values;
                const interval = Math.ceil(values.length / targetTicks);
                return values.filter((_, i) => i % interval === 0);
              }
              },
              y: { label: 'Count' }
            });
          }
          break;

        case 'area':
          plot = Plot.plot({
            ...commonOptions,
            marks: [
              Plot.areaY(plotData, {
                x: 'x',
                y: 'y',
                fill: '#3b82f6',
                fillOpacity: 0.3,
                curve: 'catmull-rom'
              }),
              Plot.line(plotData, {
                x: 'x',
                y: 'y',
                stroke: '#3b82f6',
                strokeWidth: 2,
                curve: 'catmull-rom'
              })
            ],
            x: { 
              label: chartConfig.xColumn,
              tickRotate: xIsTime ? -45 : (plotData.length > 15 ? -45 : 0),
              tickFormat: xIsTime ? (d) => formatTimeLabel(d, dataLength, chartWidth) : (d) => String(d).length > 12 ? String(d).substring(0, 12) + '...' : String(d),
              ticks: targetTicks,
              tickSpacing: Math.floor(chartWidth / targetTicks),
              tickFilter: (values: any[]) => {
                if (values.length <= targetTicks) return values;
                const interval = Math.ceil(values.length / targetTicks);
                return values.filter((_, i) => i % interval === 0);
              }
            },
            y: { label: chartConfig.yColumn }
          });
          break;

        default:
          return;
      }

      if (plot) {
        chartRef.current.appendChild(plot);
      }
    } catch (error) {
      console.error('Error creating visualization:', error);
      if (chartRef.current) {
        chartRef.current.innerHTML = '<div class="p-4 text-center text-destructive">Error creating visualization</div>';
      }
    }
  }, [chartConfig, data, isOpen]);

  // Regenerate chart when dimensions change
  useEffect(() => {
    if (isOpen && chartConfig.xColumn && chartConfig.yColumn) {
      // Small delay to allow DOM to update after resize
      const timer = setTimeout(() => {
        // Trigger chart regeneration by updating a dependency
        setChartConfig(prev => ({ ...prev }));
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [chartDimensions, isOpen, chartConfig.xColumn, chartConfig.yColumn]);

  // Resize handlers
  const handleResizeStart = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsResizing(true);
    resizeStartRef.current = {
      x: e.clientX,
      y: e.clientY,
      width: chartDimensions.width,
      height: chartDimensions.height
    };
  }, [chartDimensions]);

  const handleResizeMove = useCallback((e: MouseEvent) => {
    if (!isResizing || !resizeStartRef.current) return;
    
    e.preventDefault();
    const deltaX = e.clientX - resizeStartRef.current.x;
    const deltaY = e.clientY - resizeStartRef.current.y;
    
    const newWidth = Math.max(600, Math.min(1800, resizeStartRef.current.width + deltaX));
    const newHeight = Math.max(400, Math.min(1200, resizeStartRef.current.height + deltaY));
    
    setChartDimensions({ width: newWidth, height: newHeight });
  }, [isResizing]);

  const handleResizeEnd = useCallback(() => {
    setIsResizing(false);
    resizeStartRef.current = null;
  }, []);

  // Handle mouse events for resizing
  useEffect(() => {
    if (isResizing) {
      document.addEventListener('mousemove', handleResizeMove);
      document.addEventListener('mouseup', handleResizeEnd);
      document.body.style.cursor = 'nw-resize';
      document.body.style.userSelect = 'none';
    }

    return () => {
      document.removeEventListener('mousemove', handleResizeMove);
      document.removeEventListener('mouseup', handleResizeEnd);
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    };
  }, [isResizing, handleResizeMove, handleResizeEnd]);

  const chartTypes: { type: ChartType; label: string; icon: React.ReactNode }[] = [
    { type: 'bar', label: 'Bar Chart', icon: <BarChart3 className="h-4 w-4" /> },
    { type: 'line', label: 'Line Chart', icon: <LineChart className="h-4 w-4" /> },
    { type: 'scatter', label: 'Scatter Plot', icon: <BarChart3 className="h-4 w-4" /> },
    { type: 'histogram', label: 'Histogram', icon: <TrendingUp className="h-4 w-4" /> },
    { type: 'area', label: 'Area Chart', icon: <LineChart className="h-4 w-4" /> },
  ];

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4">
      {/* Modal Content */}
      <div className="bg-card rounded-lg shadow-2xl w-full h-full max-w-none max-h-none flex flex-col">
        {/* Modal Header */}
        <div className="flex items-center justify-between p-6 border-b border-border">
          <div className="flex items-center space-x-4">
            <h2 className="text-2xl font-bold text-foreground">Data Visualization</h2>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowSettings(!showSettings)}
            >
              <Settings className="h-4 w-4 mr-2" />
              {showSettings ? 'Hide' : 'Show'} Controls
            </Button>
          </div>
          <Button
            variant="outline"
            size="sm"
            onClick={onClose}
            className="h-10 w-10 p-0"
          >
            <X className="h-5 w-5" />
          </Button>
        </div>

        {/* Chart Controls */}
        {showSettings && (
          <div className="p-6 border-b border-border bg-muted/20">
            <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
              {/* Chart Type */}
              <div>
                <label className="text-sm font-medium mb-3 block text-foreground">Chart Type</label>
                <div className="flex flex-wrap gap-2">
                  {chartTypes.map(({ type, label, icon }) => (
                    <Button
                      key={type}
                      variant={chartConfig.type === type ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => setChartConfig(prev => ({ ...prev, type }))}
                      className="flex items-center space-x-1"
                    >
                      {icon}
                      <span className="hidden sm:inline">{label}</span>
                    </Button>
                  ))}
                </div>
              </div>

              {/* X-Axis */}
              <div>
                <label className="text-sm font-medium mb-3 block text-foreground">X-Axis</label>
                <select
                  value={chartConfig.xColumn}
                  onChange={(e) => setChartConfig(prev => ({ ...prev, xColumn: e.target.value }))}
                  className="w-full px-3 py-2 border border-border rounded-md text-sm bg-background text-foreground focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                >
                  <option value="">Select column</option>
                  {data.columns.map(column => (
                    <option key={column} value={column}>{column}</option>
                  ))}
                </select>
              </div>

              {/* Y-Axis */}
              <div>
                <label className="text-sm font-medium mb-3 block text-foreground">Y-Axis</label>
                <select
                  value={chartConfig.yColumn}
                  onChange={(e) => setChartConfig(prev => ({ ...prev, yColumn: e.target.value }))}
                  className="w-full px-3 py-2 border border-border rounded-md text-sm bg-background text-foreground focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                >
                  <option value="">Select column</option>
                  {data.columns.map(column => (
                    <option key={column} value={column}>{column}</option>
                  ))}
                </select>
              </div>

              {/* Chart Title */}
              <div>
                <label className="text-sm font-medium mb-3 block text-foreground">Chart Title</label>
                <input
                  type="text"
                  value={chartConfig.title || ''}
                  onChange={(e) => setChartConfig(prev => ({ ...prev, title: e.target.value }))}
                  placeholder="Enter chart title"
                  className="w-full px-3 py-2 border border-border rounded-md text-sm bg-background text-foreground placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                />
              </div>
            </div>
          </div>
        )}

        {/* Chart Container */}
        <div className="flex-1 flex items-center justify-center p-8 overflow-auto">
          {!chartConfig.xColumn || !chartConfig.yColumn ? (
            <div className="text-center text-muted-foreground">
              <BarChart3 className="h-16 w-16 mx-auto mb-4 opacity-50" />
              <p className="text-xl mb-2">Select columns to create a visualization</p>
              <p className="text-sm">Choose X and Y axis columns from the controls above</p>
            </div>
          ) : (
            <div className="relative">
              <div 
                ref={chartRef} 
                className="flex justify-center items-center"
                style={{ 
                  width: chartDimensions.width, 
                  height: chartDimensions.height,
                  border: isResizing ? '2px dashed hsl(var(--primary))' : '1px solid hsl(var(--border))',
                  borderRadius: '6px',
                  position: 'relative'
                }}
              />
              {/* Resize Handle */}
              <div
                className="absolute bottom-0 right-0 w-6 h-6 bg-primary/20 hover:bg-primary/40 cursor-nw-resize rounded-tl-md border-l border-t border-primary/50 flex items-center justify-center"
                onMouseDown={handleResizeStart}
                title="Drag to resize chart"
              >
                <Maximize2 className="h-3 w-3 text-primary rotate-90" />
              </div>
              {/* Chart dimensions indicator */}
              <div className="absolute top-2 left-2 bg-background/80 backdrop-blur-sm px-2 py-1 rounded text-xs text-muted-foreground border border-border">
                <div>{chartDimensions.width} × {chartDimensions.height}</div>
                {filteredTickValues && (
                  <div className="text-xs opacity-75">
                    Target Ticks: {filteredTickValues[0]}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}